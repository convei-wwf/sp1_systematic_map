---
title: "Examine FAISS outputs"
author: "O'Hara"
format: 
  html:
    code-fold: true
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
editor: source
---

This script takes the .csv files output by `1_faiss_criteria_query.qmd` and examines them:

* Plot distance curves to see whether there are steep breaks
* Examine how distance values compare to pre-screened citations from the Societal Benefits repository

```{r}
library(tidyverse)
library(ggfortify)   ### for PCA plots
library(here)
```

```{r}
faiss_query_fs <- list.files('faiss_out', pattern = '^faiss_min.+.csv$', full.names = TRUE)

faiss_q_df <- lapply(faiss_query_fs, FUN = function(f) {
  ## f <- faiss_query_fs[1]
  q <- basename(f) %>% str_remove_all('faiss_min_|.csv')
  df <- read_csv(f, show_col_types = FALSE) %>%
    mutate(query = q) %>%
    select(dist, query, citation)
}) %>%
  bind_rows()
```

## Plot distance per citation for each query

Ideally we'd see a bimodal distribution, with strong representation at low or high values but fewer intermediate values; this would resemble a stepwise function on qq plot.

```{r}
ggplot(faiss_q_df) +
  stat_qq(aes(sample = dist)) +
  facet_wrap(~ query)

ggplot(faiss_q_df) +
  geom_histogram(aes(x = dist)) +
  facet_wrap(~ query)
```

## Load screened data from SBR and sample

We can compare the screened results to the distance values here, perhaps via PCA, clustering, logistic regression... load the `_output/training_set.csv` file.

QUESTION: Since distances are all on the same unitless scale, should we rescale these distance values?  If a query shows a wide range of distances it seems it should play a greater role in differentiating than a query that reveals only a narrow range of distances.  

```{r}
screened_df <- read_csv(here('_output/training_set.csv'))


rescale <- function(x) {
  1 - (x - min(x)) / (max(x) - min(x))
}

screened_vs_faiss <- screened_df %>%
  select(author, title, include, notes, key) %>%
  left_join(faiss_q_df, by = c('key' = 'citation')) %>%
  ### convert distance to relevance: low distance = high relevance
  group_by(query) %>%
  mutate(relevance = rescale(dist)) %>%
  ungroup() %>%
  filter(!is.na(relevance))

screened_vs_faiss_geom_mean <- screened_vs_faiss %>%
  ### let d be geometric mean of rescaled relevances: if any axis is low relevance,
  ### citation is of low relevance
  group_by(author, title, include) %>%
  summarize(geom_mean = prod(relevance)^(1 / n_distinct(query)), 
            .groups = 'drop') %>%
  right_join(screened_vs_faiss)

ggplot(screened_vs_faiss_geom_mean, aes(x = relevance)) +
  geom_density(aes(fill = include), alpha = .25) +
  facet_wrap(~ query)

t.test(relevance ~ include,
       data = screened_vs_faiss_geom_mean %>% 
         select(relevance, include) %>% 
         distinct())
```

```{r}
ggplot(screened_vs_faiss_geom_mean) +
  stat_qq(aes(sample = relevance, color = include)) +
  facet_wrap(~ query)

ggplot(screened_vs_faiss_geom_mean) +
  geom_density(aes(x = relevance, fill = include), alpha = .25) +
  facet_wrap(~ query, scales = 'free_y')
```

